<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>桥梁地形云图在线高级查看器</title>
  <style>
    body { margin: 0; font-family: Arial, sans-serif; background: #1e1e1e; color: #eee; }
    header { position: fixed; top: 0; left: 0; right: 0; background: rgba(30,30,30,0.95); padding: 8px 12px; display: flex; gap: 8px; align-items: center; z-index: 10; box-shadow: 0 2px 8px rgba(0,0,0,.4); }
    select, button, input[type=range], label { font-size: 14px; }
    select, button { padding: 4px 8px; }
    #container { position: fixed; inset: 0; top: 60px; }
    #hud { position: fixed; top: 60px; left: 10px; background: rgba(0,0,0,.55); color: #fff; padding: 6px 10px; border-radius: 6px; font-size: 13px; white-space: pre; line-height: 1.5; }
    #legend { position: fixed; right: 20px; top: 80px; width: 20px; height: 200px; background: linear-gradient(to top, #0040ff, #00ffff, #00c000, #ffff00, #ff7f00, #ff0000); border: 1px solid #888; border-radius: 2px; }
    #legend::after { content: ""; position: absolute; right: 26px; top: -6px; color:#bbb; font-size: 12px; }
    #axisCanvas { position: fixed; right: 20px; bottom: 20px; width: 100px; height: 100px; background: transparent; }
    .sep { width:1px; height:22px; background:#444; margin:0 6px; }
    .muted { color:#aaa; }
    .btn-toggle[aria-pressed="true"]{ background:#315cf0; color:#fff; border:1px solid #4b74ff; }
    .btn-toggle{ background:#2a2a2a; color:#ddd; border:1px solid #444; border-radius:6px; }
  </style>
  <script type="importmap">{ "imports": { "three": "./three.module.js" } }</script>
</head>
<body>
  <header>
    <label>桥梁：</label>
    <select id="bridgeSel"></select>
    <label>时间：</label>
    <select id="dateSel"></select>
    <button id="loadBtn">加载</button>
    <div class="sep"></div>
    <label><input type="checkbox" id="pointMode"> 点显示</label>
    <label>点大小 <input type="range" id="pointSize" min="0.5" max="5" step="0.1" value="1.5"></label>
    <div class="sep"></div>
    <button id="pickBtn" class="btn-toggle" aria-pressed="false" title="单击拾取点，显示坐标与Z值">拾取</button>
    <button id="measureBtn" class="btn-toggle" aria-pressed="false" title="两点测距">测距</button>
    <button id="clearBtn">清除</button>
    <span id="status" style="margin-left:auto" class="muted">就绪</span>
  </header>
  <div id="container"></div>
  <div id="hud">提示：启用“拾取”或“测距”后，在模型上点击。
</div>
  <div id="legend" title="示意色带"></div>
  <canvas id="axisCanvas"></canvas>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from './OrbitControls.js';
    import { PLYLoader } from './PLYLoader.js';

    // ==== 场景基础 ====
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1e1e1e);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/(window.innerHeight-60), 0.1, 100000);
    camera.position.set(100,100,100);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight-60);
    document.getElementById('container').appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff,0.55));
    const dir = new THREE.DirectionalLight(0xffffff,0.9); dir.position.set(100,200,100); scene.add(dir);

    const root = new THREE.Group(); scene.add(root);

    const axesHelper = new THREE.AxesHelper(50); scene.add(axesHelper);

    // 小坐标轴视图（稳定）
    const axisScene = new THREE.Scene();
    const axisCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
    axisCamera.position.set(0,0,2);
    axisCamera.up.copy(camera.up);
    const axisRenderer = new THREE.WebGLRenderer({ canvas: document.getElementById('axisCanvas'), alpha:true, antialias:true });
    axisRenderer.setSize(100,100);
    axisScene.add(new THREE.AxesHelper(1.2));

    // ==== UI ====
    const status = document.getElementById('status');
    const hud = document.getElementById('hud');
    const pointMode = document.getElementById('pointMode');
    const pointSize = document.getElementById('pointSize');
    const pickBtn = document.getElementById('pickBtn');
    const measureBtn = document.getElementById('measureBtn');
    const clearBtn = document.getElementById('clearBtn');

    // ==== 变量 ====
    const loader = new PLYLoader();
    let currentObj = null; // Points 或 Mesh
    let measureA = null, measureB = null, measureLine = null;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function setToggle(btn, on){ btn.setAttribute('aria-pressed', on? 'true':'false'); }
    function isOn(btn){ return btn.getAttribute('aria-pressed') === 'true'; }

    function fitObject(obj){
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x,size.y,size.z) || 1;
      const dist = maxDim/(2*Math.tan(Math.PI*camera.fov/360));
      camera.position.copy(center.clone().add(new THREE.Vector3(1,1,1).normalize().multiplyScalar(dist*2)));
      controls.target.copy(center); controls.update();
      camera.near = Math.max(0.01, dist/1000); camera.far = dist*10000; camera.updateProjectionMatrix();
    }

    function clearScene(){
      if(currentObj){
        root.remove(currentObj);
        currentObj.geometry?.dispose?.();
        currentObj.material?.dispose?.();
        currentObj=null;
      }
      clearMeasure();
      hud.textContent = '提示：启用“拾取”或“测距”后，在模型上点击。';
    }

    function clearMeasure(){
      measureA = measureB = null;
      if(measureLine){ root.remove(measureLine); measureLine.geometry.dispose(); measureLine.material.dispose(); measureLine=null; }
    }

    async function loadPLY(url){
      status.textContent='加载中...';
      clearScene();
      loader.load(url,(geometry)=>{
        geometry.computeBoundingBox();
        const hasColor = !!geometry.getAttribute('color');
        const mat = pointMode.checked
          ? new THREE.PointsMaterial({ size: parseFloat(pointSize.value), vertexColors: hasColor })
          : new THREE.MeshBasicMaterial({ color:0xdddddd, wireframe:false });
        currentObj = pointMode.checked ? new THREE.Points(geometry, mat) : new THREE.Mesh(geometry, mat);
        root.add(currentObj);
        fitObject(currentObj);
        status.textContent='加载完成';
      },(xhr)=>{ if(xhr.total) status.textContent = '下载 '+(xhr.loaded/xhr.total*100).toFixed(1)+'%'; },(err)=>{ console.error(err); status.textContent='加载失败'; });
    }

    pointSize.addEventListener('input',()=>{
      if(currentObj && currentObj.material && currentObj.material.size!==undefined){ currentObj.material.size = parseFloat(pointSize.value); }
    });

    // ==== 拾取 & 测距 ====
    renderer.domElement.addEventListener('pointerdown', (e)=>{
      if(!currentObj) return;
      if(!isOn(pickBtn) && !isOn(measureBtn)) return;
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      let inter = null;
      if(currentObj.type === 'Points'){
        // 对点云进行近邻拾取
        const pts = raycaster.intersectObject(currentObj, true);
        if(pts.length) inter = pts[0];
      }else{
        const hits = raycaster.intersectObject(currentObj, true);
        if(hits.length) inter = hits[0];
      }
      if(!inter) return;

      const p = inter.point.clone();

      if(isOn(pickBtn)){
        hud.textContent = `拾取\nX: ${p.x.toFixed(3)}\nY: ${p.y.toFixed(3)}\nZ: ${p.z.toFixed(3)}`;
      }

      if(isOn(measureBtn)){
        if(!measureA){
          measureA = p.clone();
          hud.textContent = `测距(A)\nX: ${measureA.x.toFixed(3)} Y: ${measureA.y.toFixed(3)} Z: ${measureA.z.toFixed(3)}`;
        }else if(!measureB){
          measureB = p.clone();
          const dx = measureB.x - measureA.x;
          const dy = measureB.y - measureA.y;
          const dz = measureB.z - measureA.z;
          const d = Math.sqrt(dx*dx+dy*dy+dz*dz);
          hud.textContent = `测距 A→B\nΔX: ${dx.toFixed(3)}\nΔY: ${dy.toFixed(3)}\nΔZ: ${dz.toFixed(3)}\nD : ${d.toFixed(3)}`;
          // 画线
          const geo = new THREE.BufferGeometry().setFromPoints([measureA, measureB]);
          const mat = new THREE.LineBasicMaterial({ color: 0x00e0ff });
          measureLine = new THREE.Line(geo, mat);
          root.add(measureLine);
        }else{
          // 第三次点击：重新开始
          clearMeasure();
          measureA = p.clone();
          hud.textContent = `测距(A)\nX: ${measureA.x.toFixed(3)} Y: ${measureA.y.toFixed(3)} Z: ${measureA.z.toFixed(3)}`;
        }
      }
    });

    pickBtn.addEventListener('click',()=>{ setToggle(pickBtn, !isOn(pickBtn)); if(isOn(pickBtn)) setToggle(measureBtn,false); });
    measureBtn.addEventListener('click',()=>{ setToggle(measureBtn, !isOn(measureBtn)); if(isOn(measureBtn)) setToggle(pickBtn,false); });
    clearBtn.addEventListener('click', ()=>{ clearMeasure(); hud.textContent='已清除测距/拾取结果'; });

    // ==== index.json 下拉 ====
    let bridges=[], scenes=[];
    async function loadIndex(){
      const res = await fetch('./index.json?_='+Date.now());
      const data = await res.json();
      bridges = data.bridges || []; scenes = data.scenes || [];
      document.getElementById('bridgeSel').innerHTML = bridges.map(b=>`<option value="${b.id}">${b.name}</option>`).join('');
      fillDates();
    }
    function fillDates(){
      const bid=document.getElementById('bridgeSel').value;
      const arr=scenes.filter(s=>s.bridgeId===bid);
      document.getElementById('dateSel').innerHTML = arr.map(s=>`<option value="${s.id}">${s.date}</option>`).join('');
    }
    document.getElementById('bridgeSel').addEventListener('change', fillDates);
    document.getElementById('loadBtn').addEventListener('click', ()=>{
      const id=document.getElementById('dateSel').value;
      const s=scenes.find(x=>x.id===id);
      if(s) loadPLY(s.plyUrl);
    });

    // ==== 自适应 & 渲染循环 ====
    window.addEventListener('resize',()=>{
      camera.aspect = window.innerWidth/(window.innerHeight-60);
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight-60);
    });

    (function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene,camera);
      // 小坐标轴镜像主相机方向（取主相机的旋转的逆）
      axisCamera.quaternion.copy(camera.quaternion).invert();
      axisRenderer.render(axisScene, axisCamera);
    })();

    loadIndex();
  </script>
</body>
</html>
