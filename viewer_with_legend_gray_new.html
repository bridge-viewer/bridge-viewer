<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>桥梁地形云图在线查看器</title>
  <style>
    :root{
      --bg:#ececec;
      --panel:#ffffffee;
      --text:#222;
      --muted:#667085;
      --primary:#315cf0;
      --primary-weak:#e7ecff;
      --border:#d9d9d9;
      --shadow:0 6px 20px rgba(0,0,0,.08);
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Microsoft YaHei",sans-serif;color:var(--text);}
    a{color:var(--primary);text-decoration:none}
    /* 顶栏（LOGO + 标题） */
    header#topbar{
      position:sticky;top:0;left:0;right:0;z-index:20;
      display:flex;align-items:center;gap:10px;
      padding:10px 12px;background:var(--panel);backdrop-filter:saturate(180%) blur(6px);
      border-bottom:1px solid var(--border);
    }
    #logo{width:32px;height:32px;object-fit:contain;border-radius:50%}
    #title{font-size:16px;font-weight:700;letter-spacing:.5px}
    /* 工具区（两行自适应） */
    #toolbar{
      position:sticky;top:54px;z-index:19;
      display:grid;grid-template-columns:repeat(12,1fr);gap:8px;
      padding:10px 12px;background:var(--panel);border-bottom:1px solid var(--border);
    }
    .row{display:contents}
    .group{display:flex;gap:8px;align-items:center;background:#fff;border:1px solid var(--border);
      border-radius:10px;padding:8px 10px;box-shadow:var(--shadow)}
    .group label{font-size:13px;color:var(--muted)}
    select,button,.btn,input[type=range]{
      font-size:14px;border:1px solid var(--border);border-radius:8px;background:#fff;color:var(--text);
      padding:6px 10px;outline:none;
    }
    select{min-width:140px}
    button.primary{background:var(--primary);border-color:var(--primary);color:#fff}
    .toggle{padding:6px 10px;border-radius:20px;background:var(--primary-weak);border-color:#cbd5ff;color:#2946b8}
    .toggle[aria-pressed="true"]{background:var(--primary);color:#fff;border-color:var(--primary)}
    .muted{color:var(--muted)}
    /* 网格布局：第一行（桥梁与载入），第二行（显示/测距/点大小） */
    /* 12列栅格 - 更好排布到手机 */
    #g1{grid-column:span 12}
    #g2{grid-column:span 12}
    @media (min-width:860px){
      #g1{grid-column:span 7}
      #g2{grid-column:span 5}
    }
    /* 画布区 */
    #container{position:fixed;inset:0;top:128px}
    #legend{position:fixed;right:16px;top:148px;width:20px;height:200px;border:1px solid #888;
            background:linear-gradient(to top,#0000ff,#00ffff,#00ff00,#ffff00,#ff7f00,#ff0000);}
    #hud{position:fixed;left:12px;top:148px;background:rgba(0,0,0,.55);color:#fff;padding:6px 10px;border-radius:8px;font-size:13px;white-space:pre;z-index:15}
    /* 右上角校徽 */
    #brand{position:fixed;right:16px;top:10px;z-index:30;display:flex;align-items:center;gap:8px}
    #brand img{width:36px;height:36px;object-fit:contain;border-radius:50%}
    #brand .name{font-weight:700;color:#22314a;font-size:14px}
    /* 左下角水印校徽 */
    #wm{position:fixed;left:10px;bottom:10px;opacity:.10;z-index:5;pointer-events:none}
    #wm img{width:110px;height:110px;object-fit:contain}
    /* 小坐标系（正交相机，无圆圈） */
    #axisWrap{position:fixed;right:16px;bottom:16px;width:180px;height:180px;pointer-events:none}
    #axisCanvas{position:absolute;inset:0;width:180px;height:180px;background:transparent;pointer-events:auto}
  </style>
  <script type="importmap">{
    "imports": {"three":"./three.module.js"}
  }</script>
</head>
<body>
  <!-- 顶栏：LOGO + 标题 + 右上角校徽 -->
  <header id="topbar">
    <img id="logo" src="./logo.png" alt="logo" />
    <div id="title">桥梁地形云图在线查看器</div>
    <div id="brand">
      <img src="./logo.png" alt="长安大学"/>
      <span class="name">长安大学</span>
    </div>
  </header>

  <!-- 工具区（两行自适应） -->
  <section id="toolbar">
    <!-- 行1：桥梁/时间/加载 -->
    <div id="g1" class="row">
      <div class="group" style="grid-column:span 12;">
        <label>桥梁</label>
        <select id="bridgeSel"></select>
        <label>时间</label>
        <select id="dateSel"></select>
        <button id="loadBtn" class="primary">加载</button>
        <span id="status" class="muted" style="margin-left:auto">就绪</span>
      </div>
    </div>
    <!-- 行2：显示方式/点大小/拾取/测距/清除 -->
    <div id="g2" class="row">
      <div class="group" style="grid-column:span 12;flex-wrap:wrap">
        <button id="modeBtn" class="toggle" aria-pressed="false" title="切换点云/网格">网格</button>
        <label>点大小</label>
        <input type="range" id="pointSize" min="0.5" max="5" step="0.1" value="1.5" style="width:160px">
        <button id="pickBtn" class="toggle" aria-pressed="false" title="单击拾取点">拾取</button>
        <button id="measureBtn" class="toggle" aria-pressed="false" title="两点测距">测距</button>
        <button id="clearBtn" class="btn">清除</button>
      </div>
    </div>
  </section>

  <!-- 画布 / 图例 / 提示 / 小坐标系 / 水印 -->
  <div id="container"></div>
  <div id="legend" title="示意色带"></div>
  <div id="hud">提示：启用“拾取”或“测距”后，在模型上点击。</div>
  <div id="axisWrap"><canvas id="axisCanvas" width="180" height="180"></canvas></div>
  <div id="wm"><img src="./logo.png" alt="长安大学水印"/></div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from './OrbitControls.js';
    import { PLYLoader } from './PLYLoader.js';

    // ===== 场景基础 =====
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xcccccc);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/(window.innerHeight-128), 0.1, 100000);
    camera.position.set(100,100,100);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight-128);
    document.getElementById('container').appendChild(renderer.domElement);
    renderer.domElement.tabIndex = 0;

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(120, 220, 120);
    scene.add(dir);

    const root = new THREE.Group();
    scene.add(root);

    // ===== 小坐标系（正交，无外圈） =====
    const axisScene = new THREE.Scene();
    const AXIS_CANVAS_SIZE = 180;
    const AXIS_UNITS = 2.2;
    const axisCamera = new THREE.OrthographicCamera(-AXIS_UNITS, AXIS_UNITS, AXIS_UNITS, -AXIS_UNITS, -10, 10);
    axisCamera.position.set(0,0,2);
    axisCamera.up.set(0,1,0);
    axisCamera.lookAt(0,0,0);

    const axisRenderer = new THREE.WebGLRenderer({
      canvas: document.getElementById('axisCanvas'),
      alpha:true, antialias:true
    });
    axisRenderer.setSize(AXIS_CANVAS_SIZE, AXIS_CANVAS_SIZE);

    const mini = new THREE.Group(); axisScene.add(mini);
    mini.scale.set(0.95,0.95,0.95);

    function makeLabelSprite(text, color){
      const cvs=document.createElement('canvas'); const s=128; cvs.width=cvs.height=s;
      const ctx=cvs.getContext('2d');
      ctx.clearRect(0,0,s,s);
      ctx.fillStyle=color; ctx.font='bold 72px Arial';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(text,s/2,s/2);
      const tex=new THREE.CanvasTexture(cvs);
      const mat=new THREE.SpriteMaterial({map:tex,transparent:true});
      const sp=new THREE.Sprite(mat);
      sp.scale.set(0.9,0.9,0.9); // 更醒目
      return sp;
    }
    function addAxis(dir,color,name){
      const len=1.35, headLen=0.33, headWid=0.21; // 1.5x
      const ah=new THREE.ArrowHelper(dir,new THREE.Vector3(0,0,0),len,color,headLen,headWid);
      ah.userData.axis=name; ah.name='axis_'+name; mini.add(ah);
      const sp=makeLabelSprite(name,'#000000'); // 黑色
      sp.position.copy(dir.clone().multiplyScalar(1.5)); sp.userData.axis=name; mini.add(sp);
    }
    addAxis(new THREE.Vector3(1,0,0),0xff4444,'X');
    addAxis(new THREE.Vector3(0,1,0),0x44ff44,'Y');
    addAxis(new THREE.Vector3(0,0,1),0x4488ff,'Z');

    // 点击 X/Y/Z 对正
    const axisCanvas=document.getElementById('axisCanvas');
    const axisRay=new THREE.Raycaster(); const axisMouse=new THREE.Vector2();
    axisCanvas.addEventListener('pointerdown',(e)=>{
      const rect=axisCanvas.getBoundingClientRect();
      axisMouse.x=((e.clientX-rect.left)/rect.width)*2-1;
      axisMouse.y=-((e.clientY-rect.top)/rect.height)*2+1;
      axisRay.setFromCamera(axisMouse,axisCamera);
      const hits=axisRay.intersectObjects(mini.children,true);
      if(!hits.length) return;
      const hit=hits.find(h=>h.object.userData.axis);
      const axis=hit?hit.object.userData.axis:(hits[0].object.userData.axis);
      if(!axis) return; snapToAxis(axis);
      try{axisCanvas.releasePointerCapture(e.pointerId);}catch(_){}
      renderer.domElement.focus(); e.preventDefault(); e.stopPropagation();
    });

    // ===== UI元素 =====
    const status=document.getElementById('status');
    const hud=document.getElementById('hud');
    const pointSize=document.getElementById('pointSize');
    const modeBtn=document.getElementById('modeBtn'); // “网格/点云”切换按钮
    const pickBtn=document.getElementById('pickBtn');
    const measureBtn=document.getElementById('measureBtn');
    const clearBtn=document.getElementById('clearBtn');

    // ===== 变量 =====
    const loader=new PLYLoader();
    let currentObj=null;
    let asPoints=false; // 默认网格（false）
    let measureA=null, measureB=null, measureLine=null;
    const raycaster=new THREE.Raycaster(); const mouse=new THREE.Vector2();

    function fitObject(obj){
      const box=new THREE.Box3().setFromObject(obj);
      const size=box.getSize(new THREE.Vector3());
      const center=box.getCenter(new THREE.Vector3());
      const maxDim=Math.max(size.x,size.y,size.z)||1;
      const dist=maxDim/(2*Math.tan(Math.PI*camera.fov/360));
      camera.position.copy(center.clone().add(new THREE.Vector3(1,1,1).normalize().multiplyScalar(dist*2)));
      controls.target.copy(center); controls.update();
      camera.near=Math.max(0.01,dist/1000); camera.far=dist*10000; camera.updateProjectionMatrix();
    }
    function clearMeasure(){
      measureA=measureB=null;
      if(measureLine){ root.remove(measureLine); measureLine.geometry.dispose(); measureLine.material.dispose(); measureLine=null; }
    }
    function clearScene(){
      if(currentObj){ root.remove(currentObj); currentObj.geometry?.dispose?.(); currentObj.material?.dispose?.(); currentObj=null; }
      clearMeasure(); hud.textContent='提示：启用“拾取”或“测距”后，在模型上点击。';
    }
    // 彩色点/网格
    function makePoints(geometry){
      const hasColor=!!geometry.getAttribute('color');
      const mat=new THREE.PointsMaterial({ size:parseFloat(pointSize.value), vertexColors:hasColor });
      return new THREE.Points(geometry,mat);
    }
    function makeMesh(geometry){
      if(geometry.index) geometry=geometry.toNonIndexed();
      geometry.computeVertexNormals?.();
      const mat=new THREE.MeshLambertMaterial({ vertexColors:true, side:THREE.DoubleSide });
      return new THREE.Mesh(geometry,mat);
    }

    async function loadPLY(url){
      status.textContent='加载中...'; clearScene();
      loader.load(url,(geometry)=>{
        geometry.computeBoundingBox?.();
        currentObj = asPoints ? makePoints(geometry) : makeMesh(geometry);
        root.add(currentObj); fitObject(currentObj); status.textContent='加载完成';
      },(xhr)=>{ if(xhr.total) status.textContent='下载 '+(xhr.loaded/xhr.total*100).toFixed(1)+'%'; },
      (err)=>{ console.error(err); status.textContent='加载失败，请检查路径'; });
    }

    pointSize.addEventListener('input', ()=>{
      if(currentObj && currentObj.material && currentObj.material.size!==undefined){
        currentObj.material.size=parseFloat(pointSize.value);
      }
    });

    // 点/网格切换按钮
    function refreshModeLabel(){
      modeBtn.textContent = asPoints ? '点云' : '网格';
      modeBtn.setAttribute('aria-pressed', asPoints ? 'true':'false');
    }
    refreshModeLabel();
    modeBtn.addEventListener('click', ()=>{
      asPoints=!asPoints; refreshModeLabel();
      // 切换后如果已加载则重建材质
      if(currentObj){
        const url=currentScene?.plyUrl; if(url) loadPLY(url);
      }
    });

    // 拾取/测距
    function setToggle(btn,on){ btn.setAttribute('aria-pressed', on?'true':'false'); }
    function isOn(btn){ return btn.getAttribute('aria-pressed')==='true'; }
    pickBtn.addEventListener('click',()=>{ setToggle(pickBtn,!isOn(pickBtn)); if(isOn(pickBtn)) setToggle(measureBtn,false); });
    measureBtn.addEventListener('click',()=>{ setToggle(measureBtn,!isOn(measureBtn)); if(isOn(measureBtn)) setToggle(pickBtn,false); });
    clearBtn.addEventListener('click',()=>{ clearMeasure(); hud.textContent='已清除测距/拾取结果'; });

    renderer.domElement.addEventListener('pointerdown',(e)=>{
      if(!currentObj) return;
      if(!isOn(pickBtn) && !isOn(measureBtn)) return;
      const rect=renderer.domElement.getBoundingClientRect();
      mouse.x=((e.clientX-rect.left)/rect.width)*2-1;
      mouse.y=-((e.clientY-rect.top)/rect.height)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const hits=raycaster.intersectObject(currentObj,true);
      if(!hits.length) return;
      const p=hits[0].point.clone();
      if(isOn(pickBtn)){
        hud.textContent=`拾取\nX:${p.x.toFixed(3)}\nY:${p.y.toFixed(3)}\nZ:${p.z.toFixed(3)}`;
      }
      if(isOn(measureBtn)){
        if(!measureA){ measureA=p.clone();
          hud.textContent=`测距(A)\nX:${measureA.x.toFixed(3)} Y:${measureA.y.toFixed(3)} Z:${measureA.z.toFixed(3)}`;
        }else if(!measureB){ measureB=p.clone();
          const dx=measureB.x-measureA.x, dy=measureB.y-measureA.y, dz=measureB.z-measureA.z;
          const d=Math.sqrt(dx*dx+dy*dy+dz*dz);
          hud.textContent=`测距 A→B\nΔX:${dx.toFixed(3)}\nΔY:${dy.toFixed(3)}\nΔZ:${dz.toFixed(3)}\nD:${d.toFixed(3)}`;
          const geo=new THREE.BufferGeometry().setFromPoints([measureA,measureB]);
          const mat=new THREE.LineBasicMaterial({color:0x00e0ff});
          measureLine=new THREE.Line(geo,mat); root.add(measureLine);
        }else{ clearMeasure(); measureA=p.clone();
          hud.textContent=`测距(A)\nX:${measureA.x.toFixed(3)} Y:${measureA.y.toFixed(3)} Z:${measureA.z.toFixed(3)}`;
        }
      }
    });

    // index.json → 下拉
    let bridges=[], scenes=[], currentScene=null;
    async function loadIndex(){
      const res=await fetch('./index.json?_='+Date.now());
      const data=await res.json();
      bridges=data.bridges||[]; scenes=data.scenes||[];
      document.getElementById('bridgeSel').innerHTML=bridges.map(b=>`<option value="${b.id}">${b.name}</option>`).join('');
      fillDates(); // 默认选中首个桥梁
      // 默认自动加载“首条场景”且以网格显示
      const id=document.getElementById('dateSel').value;
      currentScene=scenes.find(x=>x.id===id); if(currentScene) loadPLY(currentScene.plyUrl);
    }
    function fillDates(){
      const bid=document.getElementById('bridgeSel').value;
      const arr=scenes.filter(s=>s.bridgeId===bid);
      document.getElementById('dateSel').innerHTML=arr.map(s=>`<option value="${s.id}">${s.date}</option>`).join('');
    }
    document.getElementById('bridgeSel').addEventListener('change',()=>{
      fillDates();
      const id=document.getElementById('dateSel').value;
      currentScene=scenes.find(x=>x.id===id);
    });
    document.getElementById('dateSel').addEventListener('change',()=>{
      const id=document.getElementById('dateSel').value;
      currentScene=scenes.find(x=>x.id===id);
    });
    document.getElementById('loadBtn').addEventListener('click',()=>{
      const id=document.getElementById('dateSel').value;
      currentScene=scenes.find(x=>x.id===id);
      if(currentScene) loadPLY(currentScene.plyUrl);
    });

    // 视图对正
    function getSceneCenter(){
      if(root.children.length===0) return new THREE.Vector3();
      return new THREE.Box3().setFromObject(root).getCenter(new THREE.Vector3());
    }
    function currentDistanceTo(target){ return camera.position.clone().sub(target).length(); }
    function snapToAxis(axis){
      const center=getSceneCenter();
      const dist=Math.max(1,currentDistanceTo(center));
      let pos=new THREE.Vector3(); let up=new THREE.Vector3(0,0,1);
      if(axis==='X'){ pos.set(dist,0,0); up.set(0,0,1); }
      if(axis==='Y'){ pos.set(0,dist,0); up.set(0,0,1); }
      if(axis==='Z'){ pos.set(0,0,dist); up.set(0,1,0); }
      camera.up.copy(up); camera.position.copy(center.clone().add(pos));
      controls.target.copy(center); controls.update();
    }

    // 自适应
    window.addEventListener('resize',()=>{
      camera.aspect=window.innerWidth/(window.innerHeight-128); camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight-128);
      axisRenderer.setSize(AXIS_CANVAS_SIZE,AXIS_CANVAS_SIZE);
      axisCamera.left=-AXIS_UNITS; axisCamera.right=AXIS_UNITS;
      axisCamera.top=AXIS_UNITS; axisCamera.bottom=-AXIS_UNITS; axisCamera.updateProjectionMatrix();
    });

    // 循环
    (function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene,camera);
      mini.position.set(0,0,0); mini.quaternion.copy(camera.quaternion);
      axisCamera.lookAt(0,0,0); axisRenderer.render(axisScene,axisCamera);
    })();

    loadIndex();
  </script>
</body>
</html>
