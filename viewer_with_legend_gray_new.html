<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>桥梁水下河床3D声呐模型孪生系统</title>
<style>
:root{
  --bg:#cccccc;
  --panel:#ffffffee; --text:#222; --muted:#667085;
  --primary:#315cf0; --primary-weak:#e7ecff; --border:#d9d9d9; --shadow:0 6px 20px rgba(0,0,0,.08);
  --safe-b: env(safe-area-inset-bottom, 12px);
}
*{box-sizing:border-box} body{margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Microsoft YaHei",sans-serif;color:var(--text);}

#topbar{position:sticky;top:0;z-index:30;display:flex;gap:10px;align-items:center;padding:10px 12px;background:var(--panel);backdrop-filter:saturate(180%) blur(6px);border-bottom:1px solid var(--border)}
#logo{width:32px;height:32px;border-radius:50%}
#title{font-size:16px;font-weight:700}
#brand{margin-left:auto;display:flex;align-items:center;gap:8px}
#brand img{width:36px;height:36px;border-radius:50%}
#brand .name{font-weight:700;color:#22314a;font-size:14px}

#toolbar{position:sticky;top:54px;z-index:25;display:grid;grid-template-columns:repeat(12,1fr);gap:8px;padding:10px 12px;background:var(--panel);border-bottom:1px solid var(--border)}
.row{display:contents}
.group{display:flex;gap:8px;align-items:center;background:#fff;border:1px solid var(--border);border-radius:10px;padding:8px 10px;box-shadow:var(--shadow)}
.group label{font-size:13px;color:var(--muted)}
select,button,input[type=range]{font-size:14px;border:1px solid var(--border);border-radius:8px;background:#fff;color:#fff;color:var(--text);padding:6px 10px}
select{min-width:140px} button.primary{background:var(--primary);border-color:var(--primary);color:#fff}
.toggle{padding:6px 10px;border-radius:20px;background:var(--primary-weak);border-color:#cbd5ff;color:#2946b8}
.toggle[aria-pressed="true"]{background:var(--primary);color:#fff;border-color:var(--primary)}
.muted{color:var(--muted)}
#g1{grid-column:span 12} #g2{grid-column:span 12}
@media (min-width:860px){ #g1{grid-column:span 7} #g2{grid-column:span 5} }

#container{position:fixed;inset:0;top:128px}

#hud{position:fixed;left:12px;bottom:var(--safe-b);transform:translateY(-6px);background:rgba(0,0,0,.7);color:#fff;padding:8px 10px;border-radius:8px;font-size:13px;white-space:pre;z-index:24}
#wm{position:fixed;left:12px;bottom:calc(var(--safe-b) + 64px);opacity:.10;z-index:10;pointer-events:none}
#wm img{width:96px;height:96px;object-fit:contain}
#axisWrap{position:fixed;right:12px;bottom:var(--safe-b);width:160px;height:160px;pointer-events:none;z-index:24}
#axisCanvas{position:absolute;inset:0;width:160px;height:160px;background:transparent;pointer-events:auto}

#progressWrap{
  position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
  min-width:240px; padding:12px 16px; background:rgba(0,0,0,.7); color:#fff;
  border-radius:12px; z-index:40; display:none; text-align:center;
  box-shadow:0 8px 30px rgba(0,0,0,.25);
}
#progressBar{width:100%; height:10px; background:rgba(255,255,255,.25); border-radius:999px; overflow:hidden; margin-top:8px}
#progressFill{height:100%; width:0%; background:#4ad5ff; border-radius:999px; transition:width .2s ease}

#legendDock{
  position:fixed; left:12px; top:50%; transform:translateY(-50%); z-index:22;
  display:flex; flex-direction:column; align-items:flex-start; gap:6px; pointer-events:none;
}
#legendTitle{
  font-size:12px; color:#333; background:var(--bg); padding:4px 6px; border-radius:6px;
  border:1px solid rgba(0,0,0,.2);
}
#legendWrap{
  display:flex; align-items:flex-start; gap:6px;
  background:var(--bg); border:1px solid rgba(0,0,0,.25);
  border-radius:6px; padding:6px; pointer-events:auto;
}
#legend{display:block; width:24px; height:240px; border:1px solid #888}
#legendTicks{
  display:flex; flex-direction:column; gap:0; font-size:12px; color:#000;
  font-family:"Times New Roman", Times, serif; line-height:1; width:46px; text-align:right;
}
#legendTicks div{height:calc(240px/10); display:flex; align-items:center; justify-content:flex-end; padding-right:2px}

#zPanel{
  height:240px; width:40px;
  display:flex; flex-direction:column; align-items:center; gap:6px;
  background:rgba(255,255,255,.9); border:1px solid rgba(0,0,0,.15);
  border-radius:6px; padding:6px 4px;
}
#zPanel input[type=range]{
  writing-mode: bt-lr; -webkit-appearance: slider-vertical;
  width:26px; height:100%;
}
#zPanel .label{font-size:12px;line-height:1.1;text-align:center;color:#333}
#zPanel .val{font-size:12px;color:#333}

#status{margin-left:auto}

/* 隐藏校名/校徽/水印 + 只隐藏“第一行”桥梁/时间/加载 */
#brand,#logo,#wm,#topbar,#g1{ display:none !important; }
</style>

<script type="importmap">{"imports":{"three":"./three.module.js"}}</script>
</head>
<body>
  <header id="topbar">
    <img id="logo" src="./logo.png" alt="logo"/>
    <div id="title">桥梁水下河床3D声呐模型孪生系统</div>
    <div id="brand"><img src="./logo.png" alt="长安大学"/><span class="name">长安大学</span></div>
  </header>

  <section id="toolbar">
    <div id="g1" class="row">
      <div class="group" style="grid-column:span 12;">
        <label>桥梁</label><select id="bridgeSel"></select>
        <label>时间</label><select id="dateSel"></select>
        <button id="loadBtn" class="primary">加载</button>
        <span id="status" class="muted">就绪</span>
      </div>
    </div>
    <div id="g2" class="row">
      <div class="group" style="grid-column:span 12;flex-wrap:wrap">
        <button id="modeBtn" class="toggle" aria-pressed="false">曲面</button>
        <label>点大小</label><input type="range" id="pointSize" min="0.5" max="5" step="0.1" value="1.5" style="width:160px">
        <button id="pickBtn" class="toggle" aria-pressed="false">拾取</button>
        <button id="measureBtn" class="toggle" aria-pressed="false">测距</button>
        <button id="clearBtn" class="toggle" aria-pressed="false">清除</button>
      </div>
    </div>
  </section>

  <div id="container"></div>

  <aside id="legendDock">
    <div id="legendTitle">河床深度 / m</div>
    <div id="legendWrap">
      <div id="legendTicks"></div>
      <canvas id="legend" width="24" height="240"></canvas>

      <div id="zPanel">
        <div class="label">深度<br>放大</div>
        <input id="zScale" type="range" min="1" max="10" step="0.1" value="1" aria-label="深度放大">
        <div id="zScaleLabel" class="val">×1.0</div>
      </div>
    </div>
  </aside>

  <div id="progressWrap">
    <div id="progressText">加载中…</div>
    <div id="progressBar"><div id="progressFill"></div></div>
  </div>

  <div id="hud">提示：启用“拾取”或“测距”后，在模型上点击。</div>
  <div id="axisWrap"><canvas id="axisCanvas" width="160" height="160"></canvas></div>
  <div id="wm"><img src="./logo.png" alt="长安大学水印"/></div>

  <script type="module">
    import * as THREE from 'three';
    import { PLYLoader } from './PLYLoader.js';

    /* 场景 */
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--bg').trim());

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/(window.innerHeight-128), 0.1, 100000);
    camera.position.set(100,100,100);
    camera.up.set(0,0,1);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight-128);
    document.getElementById('container').appendChild(renderer.domElement);
    renderer.domElement.tabIndex = 0;

    renderer.domElement.addEventListener('contextmenu', (e)=>e.preventDefault());

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const d = new THREE.DirectionalLight(0xffffff, 0.9); d.position.set(120,220,120); scene.add(d);

    const root = new THREE.Group(); scene.add(root);

    /* 小坐标系（正交） */
    const axisScene = new THREE.Scene();
    const AXIS_UNITS = 2.2;
    const axisCamera = new THREE.OrthographicCamera(-AXIS_UNITS, AXIS_UNITS, AXIS_UNITS, -AXIS_UNITS, -10, 10);
    axisCamera.position.set(0,0,2); axisCamera.up.set(0,1,0); axisCamera.lookAt(0,0,0);
    const axisRenderer = new THREE.WebGLRenderer({canvas: document.getElementById('axisCanvas'), alpha:true, antialias:true});
    axisRenderer.setSize(160,160);
    const mini = new THREE.Group(); axisScene.add(mini); mini.scale.set(0.95,0.95,0.95);
    function makeLabelSprite(t,c){const s=128,cv=document.createElement('canvas');cv.width=cv.height=s;const ctx=cv.getContext('2d');
      ctx.clearRect(0,0,s,s);ctx.fillStyle=c;ctx.font='bold 72px Arial';ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(t,s/2,s/2);
      const tx=new THREE.CanvasTexture(cv);return new THREE.Sprite(new THREE.SpriteMaterial({map:tx,transparent:true}))}
    function addAxis(dir,color,name){const len=1.35, headLen=0.33, headWid=0.21;
      const ah=new THREE.ArrowHelper(dir,new THREE.Vector3(0,0,0),len,color,headLen,headWid); mini.add(ah);
      const sp=makeLabelSprite(name,'#000'); sp.scale.set(0.9,0.9,0.9); sp.position.copy(dir.clone().multiplyScalar(1.5)); mini.add(sp);}
    addAxis(new THREE.Vector3(1,0,0),0xff4444,'X'); addAxis(new THREE.Vector3(0,1,0),0x44ff44,'Y'); addAxis(new THREE.Vector3(0,0,1),0x4488ff,'Z');

    /* UI */
    const statusEl=document.getElementById('status');
    const hud=document.getElementById('hud');
    const pointSize=document.getElementById('pointSize');
    const modeBtn=document.getElementById('modeBtn');
    const pickBtn=document.getElementById('pickBtn');
    const measureBtn=document.getElementById('measureBtn');
    const clearBtn=document.getElementById('clearBtn');

    const zScaleEl = document.getElementById('zScale');
    const zScaleLabel = document.getElementById('zScaleLabel');

    const progressWrap = document.getElementById('progressWrap');
    const progressText = document.getElementById('progressText');
    const progressFill = document.getElementById('progressFill');

    /* 变量 */
    const loader=new PLYLoader(); let currentObj=null, asPoints=false;
    let measureA=null, measureB=null, measureLine=null, measureAMarker=null, measureBMarker=null;
    let pickMarker=null;

    const rc=new THREE.Raycaster(), mouse=new THREE.Vector2();

    // 视图参考点（用于缩放平面/平移尺度）
    const orbitTarget = new THREE.Vector3(0,0,0);

    function lookAtTarget(){
      camera.lookAt(orbitTarget);
      camera.updateMatrixWorld();
    }

    /* 工具函数 */
    function sceneScale(){
      const b=new THREE.Box3().setFromObject(root);
      const s=b.getSize(new THREE.Vector3());
      return Math.max(s.x,s.y,s.z)||1;
    }

    // 重拾取（用于：中键按下时确定旋转中心；次数很少）
    function pickPointFromEvent(e){
      const r = renderer.domElement.getBoundingClientRect();
      mouse.set(
        ((e.clientX - r.left)/r.width)*2 - 1,
        -((e.clientY - r.top)/r.height)*2 + 1
      );

      rc.setFromCamera(mouse, camera);
      rc.params.Points.threshold = sceneScale() * 0.01;

      if (currentObj){
        const hits = rc.intersectObject(currentObj, true);
        if (hits.length) return hits[0].point.clone();
      }

      const camDir = new THREE.Vector3();
      camera.getWorldDirection(camDir);
      const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(camDir, orbitTarget);
      const p = new THREE.Vector3();
      const ok = rc.ray.intersectPlane(plane, p);
      return ok ? p : orbitTarget.clone();
    }

    // 轻拾取（用于：滚轮缩放；每帧最多一次，不做模型相交）
    function pickPointOnTargetPlane(clientX, clientY){
      const r = renderer.domElement.getBoundingClientRect();
      mouse.set(
        ((clientX - r.left)/r.width)*2 - 1,
        -((clientY - r.top)/r.height)*2 + 1
      );
      rc.setFromCamera(mouse, camera);

      const camDir = new THREE.Vector3();
      camera.getWorldDirection(camDir);

      const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(camDir, orbitTarget);
      const p = new THREE.Vector3();
      const ok = rc.ray.intersectPlane(plane, p);
      return ok ? p : orbitTarget.clone();
    }

    /* ========= SolidWorks 风格相机交互（不使用 OrbitControls） ========= */

    let isRotating=false, isPanning=false;
    let activePointerId=null;

    // 旋转中心（鼠标中键按下时取）
    const rotatePivot = new THREE.Vector3();

    // 旋转：用“相对按下瞬间”的总位移来算 yaw/pitch（而不是每帧叠加）
    const ROTATE_SPEED = 1.0;
    const WORLD_UP = new THREE.Vector3(0,0,1);

    let rotStartX=0, rotStartY=0;
    const camPos0 = new THREE.Vector3();
    const camQuat0 = new THREE.Quaternion();
    const right0 = new THREE.Vector3();
    const tmpRight = new THREE.Vector3();
    const qYaw = new THREE.Quaternion();
    const qPitch = new THREE.Quaternion();
    const qRot = new THREE.Quaternion();
    const offset = new THREE.Vector3();

    // 平移（右键）
    let lastX=0, lastY=0;

    function applyRotationFromStart(clientX, clientY){
      const el = renderer.domElement;
      const w = el.clientWidth || 1;
      const h = el.clientHeight || 1;

      const dx = clientX - rotStartX;
      const dy = clientY - rotStartY;

      // ✅ 只改这里：乘 -1，反转方向
      const yaw   = (-dx / w) * Math.PI * 2 * ROTATE_SPEED;
      const pitch = (-dy / h) * Math.PI * 2 * ROTATE_SPEED;

      qYaw.setFromAxisAngle(WORLD_UP, yaw);
      tmpRight.copy(right0).applyQuaternion(qYaw).normalize();
      qPitch.setFromAxisAngle(tmpRight, pitch);

      qRot.copy(qYaw).multiply(qPitch);

      offset.copy(camPos0).sub(rotatePivot).applyQuaternion(qRot);
      camera.position.copy(rotatePivot).add(offset);

      camera.quaternion.copy(qRot).multiply(camQuat0);
      camera.quaternion.normalize();
      camera.updateMatrixWorld();
    }

    function applyPan(dx, dy){
      const hh = (renderer.domElement.clientHeight || 1);

      const dist = Math.max(0.0001, camera.position.distanceTo(orbitTarget));
      const vFov = THREE.MathUtils.degToRad(camera.fov);
      const worldPerPixel = 2 * dist * Math.tan(vFov/2) / hh;

      const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion).normalize();
      const up    = new THREE.Vector3(0,1,0).applyQuaternion(camera.quaternion).normalize();

      const pan = new THREE.Vector3();
      pan.addScaledVector(right, -dx * worldPerPixel);
      pan.addScaledVector(up,    dy * worldPerPixel);

      camera.position.add(pan);
      orbitTarget.add(pan);
      rotatePivot.add(pan);
      camera.updateMatrixWorld();
    }

    renderer.domElement.addEventListener('pointerdown', (e)=>{
      if (e.pointerType !== 'mouse') return;

      // 中键：旋转
      if (e.button === 1){
        e.preventDefault(); e.stopPropagation();
        activePointerId = e.pointerId;
        renderer.domElement.setPointerCapture(activePointerId);

        isRotating = true; isPanning = false;

        rotStartX = e.clientX; rotStartY = e.clientY;

        rotatePivot.copy(pickPointFromEvent(e));
        orbitTarget.copy(rotatePivot);

        camPos0.copy(camera.position);
        camQuat0.copy(camera.quaternion);
        right0.set(1,0,0).applyQuaternion(camQuat0).normalize();
        return;
      }

      // 右键：平移
      if (e.button === 2){
        e.preventDefault(); e.stopPropagation();
        activePointerId = e.pointerId;
        renderer.domElement.setPointerCapture(activePointerId);

        isPanning = true; isRotating = false;
        lastX = e.clientX; lastY = e.clientY;
        return;
      }
    }, true);

    renderer.domElement.addEventListener('pointermove', (e)=>{
      if (activePointerId == null || e.pointerId !== activePointerId) return;

      if (isRotating){
        applyRotationFromStart(e.clientX, e.clientY);
        return;
      }

      if (isPanning){
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;
        applyPan(dx, dy);
        return;
      }
    }, true);

    function endPointer(e){
      if (activePointerId == null || e.pointerId !== activePointerId) return;
      try{ renderer.domElement.releasePointerCapture(activePointerId); }catch(_){}
      activePointerId = null;
      isRotating = false;
      isPanning = false;
    }
    renderer.domElement.addEventListener('pointerup', endPointer, true);
    renderer.domElement.addEventListener('pointercancel', endPointer, true);

    /* ✅ 缩放：wheel 合并到每帧一次 + 轻拾取（不卡） */
    const ZOOM_SPEED = 0.0016;

    let wheelRAF = 0;
    let wheelDeltaAcc = 0;
    let wheelClientX = 0;
    let wheelClientY = 0;

    function applyWheelZoom(){
      wheelRAF = 0;

      const delta = wheelDeltaAcc;
      wheelDeltaAcc = 0;

      const zoomPoint = pickPointOnTargetPlane(wheelClientX, wheelClientY);
      orbitTarget.copy(zoomPoint);

      let scale = Math.exp(delta * ZOOM_SPEED);
      scale = Math.min(1.25, Math.max(0.80, scale));

      const v = camera.position.clone().sub(zoomPoint);
      const curLen = v.length();
      const minLen = Math.max(0.02, sceneScale()*0.0005);
      const nextLen = curLen * scale;
      if (nextLen < minLen) return;

      v.multiplyScalar(scale);
      camera.position.copy(zoomPoint.clone().add(v));
      camera.updateMatrixWorld();
    }

    renderer.domElement.addEventListener('wheel', (e)=>{
      e.preventDefault();

      wheelDeltaAcc += e.deltaY;
      wheelClientX = e.clientX;
      wheelClientY = e.clientY;

      if (!wheelRAF) wheelRAF = requestAnimationFrame(applyWheelZoom);
    }, { passive:false });

    /* ========= 业务逻辑（原有） ========= */
    function makeMarker(color){
      const s=sceneScale()*0.012;
      const g=new THREE.SphereGeometry(s,16,16);
      const m=new THREE.MeshBasicMaterial({color});
      const o=new THREE.Mesh(g,m);
      const edge=new THREE.Mesh(
        new THREE.SphereGeometry(s*1.35,16,16),
        new THREE.MeshBasicMaterial({color:0xffffff,opacity:.85,transparent:true})
      );
      const grp=new THREE.Group(); grp.add(edge); grp.add(o); return grp;
    }

    function makeMeasureLine(a,b){
      const geo=new THREE.BufferGeometry().setFromPoints([a,b]);
      const mat=new THREE.LineBasicMaterial({color:0x00e0ff,linewidth:2,transparent:true,opacity:.95});
      return new THREE.Line(geo,mat);
    }

    function updateMeasureLine(){
      if(measureLine&&measureA&&measureB){
        const p=measureLine.geometry.attributes.position.array;
        p[0]=measureA.x;p[1]=measureA.y;p[2]=measureA.z;
        p[3]=measureB.x;p[4]=measureB.y;p[5]=measureB.z;
        measureLine.geometry.attributes.position.needsUpdate=true;
        measureLine.geometry.computeBoundingSphere?.();
      }
    }

    function fitObject(obj){
      const b=new THREE.Box3().setFromObject(obj);
      const s=b.getSize(new THREE.Vector3());
      const c=b.getCenter(new THREE.Vector3());
      orbitTarget.copy(c);

      const md=Math.max(s.x,s.y,s.z)||1;
      const dist=md/(2*Math.tan(Math.PI*camera.fov/360));
      const dir = new THREE.Vector3(-1, 1, 0.5).normalize();
      camera.position.copy(c.clone().add(dir.multiplyScalar(dist*2)));

      camera.near=Math.max(0.01,dist/1000);
      camera.far=dist*10000;
      camera.updateProjectionMatrix();

      camera.up.set(0,0,1);
      lookAtTarget();
    }

    function clearMeasure(){
      measureA=measureB=null;
      if(measureLine){root.remove(measureLine);measureLine.geometry.dispose();measureLine.material.dispose();measureLine=null;}
      if(measureAMarker){root.remove(measureAMarker);measureAMarker=null;}
      if(measureBMarker){root.remove(measureBMarker);measureBMarker=null;}
    }

    function clearPick(){
      if(pickMarker){root.remove(pickMarker);pickMarker=null;}
    }

    function clearScene(){
      if(currentObj){
        root.remove(currentObj);
        currentObj.geometry?.dispose?.();
        currentObj.material?.dispose?.();
        currentObj=null;
      }
      clearMeasure();clearPick();
      hud.textContent='提示：启用“拾取”或“测距”后，在模型上点击。';
    }

    function makePoints(geo){
      const hasColor=!!geo.getAttribute('color');
      const mat=new THREE.PointsMaterial({size:parseFloat(pointSize.value),vertexColors:hasColor});
      return new THREE.Points(geo,mat);
    }

    function makeMesh(geo){
      if(geo.index) geo=geo.toNonIndexed();
      geo.computeVertexNormals?.();
      const mat=new THREE.MeshLambertMaterial({vertexColors:true,side:THREE.DoubleSide});
      return new THREE.Mesh(geo,mat);
    }

    // 深度放大（Z 轴）
    let currentZ = 1;
    function applyZScale(v){
      currentZ = v;
      if(currentObj){ currentObj.scale.set(1, 1, v); }
    }

    /* 图例 */
    const legendCv=document.getElementById('legend');
    const lctx=legendCv.getContext('2d');
    const ticksEl=document.getElementById('legendTicks');

    let legendSpec = {
      min:-10.0, max:-4.0,
      colors: ['#0010a8','#123fdf','#1491ff','#18cfff','#18fffb','#55ff13','#c7ff00','#ffd200','#ff7a00','#e10000']
    };

    function drawLegendDiscrete(){
      const n=legendSpec.colors.length, w=legendCv.width, h=legendCv.height, seg=h/n;
      lctx.clearRect(0,0,w,h);
      for(let i=0;i<n;i++){
        const y=h - (i+1)*seg;
        lctx.fillStyle=legendSpec.colors[i];
        lctx.fillRect(0, y, w, seg);
        lctx.strokeStyle="#888"; lctx.lineWidth=1; lctx.strokeRect(0, y, w, seg);
      }
      ticksEl.innerHTML='';
      const ticks=10, top=legendSpec.max, bot=legendSpec.min;
      for(let i=0;i<ticks;i++){
        const v = top - (i)*( (top-bot)/(ticks-1) );
        const dd=document.createElement('div'); dd.textContent = v.toFixed(3); ticksEl.appendChild(dd);
      }
    }
    drawLegendDiscrete();

    async function tryLoadLegend(plyUrl){
      try{
        const u = new URL(plyUrl, location.href), name=u.pathname.split('/').pop(), base=name.replace(/\.ply$/i,'');
        u.pathname = u.pathname.replace(name, base+'.legend.json');
        const r = await fetch(u.href+'?_='+Date.now()); if(!r.ok) return;
        const j = await r.json(); const s=j.legend||j;
        if(s.min!=null && s.max!=null && Array.isArray(s.stops)){
          const cols = s.stops.map(p=>p[1]);
          legendSpec = {min:s.min, max:s.max, colors: cols};
          drawLegendDiscrete();
        }
      }catch(_){}
    }

    async function loadPLY(url){
      statusEl.textContent='加载中...';
      progressWrap.style.display='block';
      progressText.textContent='加载中…';
      progressFill.style.width='0%';

      clearScene();
      tryLoadLegend(url);

      loader.load(url,(geo)=>{
        geo.computeBoundingBox?.();
        currentObj = asPoints? makePoints(geo): makeMesh(geo);
        root.add(currentObj);

        applyZScale(currentZ);
        fitObject(currentObj);

        statusEl.textContent='加载完成';
        progressFill.style.width='100%';
        progressText.textContent='100%';
        setTimeout(()=>{progressWrap.style.display='none';}, 400);
      },(xhr)=>{
        if (xhr.total){
          const pct = Math.min(99, Math.floor(xhr.loaded / xhr.total * 100));
          progressFill.style.width = pct + '%';
          progressText.textContent = pct + '%';
          statusEl.textContent = '下载 ' + pct + '%';
        }else{
          progressText.textContent = '加载中…';
          const cur = parseFloat(progressFill.style.width) || 0;
          const nxt = (cur + 2) % 90;
          progressFill.style.width = nxt + '%';
        }
      },(err)=>{
        console.error(err);
        statusEl.textContent='加载失败';
        progressText.textContent='加载失败';
        setTimeout(()=>{progressWrap.style.display='none';}, 1200);
      });
    }

    pointSize.addEventListener('input',()=>{
      if(currentObj&&currentObj.material&&currentObj.material.size!==undefined){
        currentObj.material.size=parseFloat(pointSize.value);
      }
    });

    function toggle(btn){btn.setAttribute('aria-pressed', btn.getAttribute('aria-pressed')==='true'?'false':'true');}
    function isOn(btn){return btn.getAttribute('aria-pressed')==='true';}

    modeBtn.addEventListener('click',()=>{
      asPoints=!asPoints;
      modeBtn.textContent=asPoints?'点云':'曲面';
      if(currentObj&&currentScene?.plyUrl) loadPLY(currentScene.plyUrl);
    });

    pickBtn.addEventListener('click',()=>{
      toggle(pickBtn);
      pickBtn.textContent = isOn(pickBtn) ? '拾取✓' : '拾取';
      if(isOn(pickBtn)) {measureBtn.setAttribute('aria-pressed','false'); measureBtn.textContent='测距';}
    });

    measureBtn.addEventListener('click',()=>{
      toggle(measureBtn);
      measureBtn.textContent = isOn(measureBtn) ? '测距✓' : '测距';
      if(isOn(measureBtn)) {pickBtn.setAttribute('aria-pressed','false'); pickBtn.textContent='拾取';}
    });

    clearBtn.addEventListener('click',()=>{
      clearMeasure(); clearPick();
      hud.textContent='已清除测距/拾取结果';
    });

    zScaleEl.addEventListener('input', ()=>{
      const v = parseFloat(zScaleEl.value) || 1;
      applyZScale(v);
      zScaleLabel.textContent = '×' + v.toFixed(1);
    });
    applyZScale(parseFloat(zScaleEl.value) || 1);

    /* 主画布点击：拾取/测距 */
    renderer.domElement.addEventListener('pointerdown',(e)=>{
      if (e.pointerType === 'mouse' && e.button !== 0) return;

      if(!currentObj) return;
      if(!isOn(pickBtn)&&!isOn(measureBtn)) return;

      const r=renderer.domElement.getBoundingClientRect();
      const mm=new THREE.Vector2(
        ((e.clientX-r.left)/r.width)*2-1,
        -((e.clientY-r.top)/r.height)*2+1
      );

      const rcc=new THREE.Raycaster();
      rcc.setFromCamera(mm,camera);
      rcc.params.Points.threshold = sceneScale() * 0.01;

      const h=rcc.intersectObject(currentObj,true);
      if(!h.length) return;
      const p=h[0].point.clone();

      if(isOn(pickBtn)){
        clearPick();
        pickMarker=makeMarker(0x9a4dff);
        pickMarker.position.copy(p);
        root.add(pickMarker);
        hud.textContent=`拾取\nX:${p.x.toFixed(3)}\nY:${p.y.toFixed(3)}\nZ:${p.z.toFixed(3)}`;
      }

      if(isOn(measureBtn)){
        if(!measureA){
          measureA=p.clone();
          if(measureAMarker) root.remove(measureAMarker);
          measureAMarker=makeMarker(0x00e0ff);
          measureAMarker.position.copy(measureA);
          root.add(measureAMarker);
          hud.textContent=`测距(A)\nX:${measureA.x.toFixed(3)}\nY:${measureA.y.toFixed(3)}\nZ:${measureA.z.toFixed(3)}`;
        } else if(!measureB){
          measureB=p.clone();
          if(measureBMarker) root.remove(measureBMarker);
          measureBMarker=makeMarker(0xff6a00);
          measureBMarker.position.copy(measureB);
          root.add(measureBMarker);

          if(!measureLine){ measureLine=makeMeasureLine(measureA,measureB); root.add(measureLine); }
          else updateMeasureLine();

          const dx=measureB.x-measureA.x, dy=measureB.y-measureA.y, dz=measureB.z-measureA.z;
          const D=Math.sqrt(dx*dx+dy*dy+dz*dz);
          hud.textContent=`ΔX:${dx.toFixed(3)}\nΔY:${dy.toFixed(3)}\nΔZ:${dz.toFixed(3)}\nD:${D.toFixed(3)}`;
        } else {
          clearMeasure();
          measureA=p.clone();
          measureAMarker=makeMarker(0x00e0ff);
          measureAMarker.position.copy(measureA);
          root.add(measureAMarker);
          hud.textContent=`测距(A)\nX:${measureA.x.toFixed(3)}\nY:${measureA.y.toFixed(3)}\nZ:${measureA.z.toFixed(3)}`;
        }
      }
    });

    /* 下拉数据 */
    let bridges=[], scenes=[], currentScene=null;

    function getParam(name){ return new URLSearchParams(location.search).get(name); }

    async function loadIndex(){
      const res = await fetch('./index.json?_=' + Date.now());
      const data = await res.json();
      bridges = data.bridges || [];
      scenes  = data.scenes  || [];

      const bridgeSel = document.getElementById('bridgeSel');
      const dateSel   = document.getElementById('dateSel');

      bridgeSel.innerHTML = bridges.map(b=>`<option value="${b.id}">${b.name}</option>`).join('');

      const sceneId = getParam('scene');
      if (sceneId) {
        currentScene = scenes.find(s => s.id === sceneId) || null;
        if (currentScene) {
          bridgeSel.value = currentScene.bridgeId;
          const sameBridgeScenes = scenes.filter(s => s.bridgeId === currentScene.bridgeId);
          dateSel.innerHTML = sameBridgeScenes.map(s => `<option value="${s.id}">${s.date}</option>`).join('');
          dateSel.value = currentScene.id;
          loadPLY(currentScene.plyUrl);
          return;
        }
      }

      fillDates();
      const id = dateSel.value;
      currentScene = scenes.find(x => x.id === id);
      if (currentScene) loadPLY(currentScene.plyUrl);
    }

    function fillDates(){
      const bid=document.getElementById('bridgeSel').value;
      const arr=scenes.filter(s=>s.bridgeId===bid);
      document.getElementById('dateSel').innerHTML=arr.map(s=>`<option value="${s.id}">${s.date}</option>`).join('');
    }

    document.getElementById('bridgeSel').addEventListener('change',()=>{
      fillDates();
      const id=document.getElementById('dateSel').value;
      currentScene=scenes.find(x=>x.id===id);
    });

    document.getElementById('dateSel').addEventListener('change',()=>{
      const id=document.getElementById('dateSel').value;
      currentScene=scenes.find(x=>x.id===id);
    });

    document.getElementById('loadBtn').addEventListener('click',()=>{
      const id=document.getElementById('dateSel').value;
      currentScene=scenes.find(x=>x.id===id);
      if(currentScene) loadPLY(currentScene.plyUrl);
    });

    /* 自适应 */
    window.addEventListener('resize',()=>{
      camera.aspect=window.innerWidth/(window.innerHeight-128);
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight-128);
      axisRenderer.setSize(160,160);
    });

    /* 渲染循环 */
    (function ani(){
      requestAnimationFrame(ani);
      renderer.render(scene,camera);
      mini.quaternion.copy(camera.quaternion);
      axisCamera.lookAt(0,0,0);
      axisRenderer.render(axisScene,axisCamera);
    })();

    loadIndex();
  </script>
</body>
</html>
