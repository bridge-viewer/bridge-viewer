<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>三维模型</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #mainCanvas { display: block; }
    #axisCanvas { position: absolute; top: 0; left: 0; }
  </style>
</head>
<body>
  <canvas id="mainCanvas"></canvas>
  <canvas id="axisCanvas" width="160" height="160"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    /* 场景 */
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--bg')?.trim() || "#ffffff");

    /* 相机：改为正交相机（轴测图） */
    const aspect = window.innerWidth / (window.innerHeight - 128);
    const frustumSize = 200;
    const camera = new THREE.OrthographicCamera(
      (frustumSize * aspect) / -2,
      (frustumSize * aspect) /  2,
      frustumSize / 2,
      frustumSize / -2,
      -10000,
      10000
    );
    // 设置初始等轴测角度
    camera.position.set(100, 100, 100);
    camera.up.set(0, 0, -1);   // Z 轴朝下
    camera.lookAt(0, 0, 0);

    /* 渲染器 */
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById("mainCanvas"), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight - 128);

    /* 控件 */
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    /* 坐标轴小窗口 */
    const axisScene = new THREE.Scene();
    const axisCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 10);
    axisCamera.up = camera.up;  // 保持相同 up
    axisCamera.position.z = 2;
    const axisRenderer = new THREE.WebGLRenderer({ canvas: document.getElementById("axisCanvas"), alpha: true });
    axisRenderer.setSize(160, 160);
    const axesHelper = new THREE.AxesHelper(1);
    axisScene.add(axesHelper);

    /* 示例几何体 */
    const geometry = new THREE.BoxGeometry(50, 50, 50);
    const material = new THREE.MeshNormalMaterial();
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    /* 动画循环 */
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);

      // 小窗口坐标轴跟随
      axisCamera.quaternion.copy(camera.quaternion);
      axisRenderer.render(axisScene, axisCamera);
    }
    animate();

    /* 自适应 */
    window.addEventListener('resize', () => {
      const aspect = window.innerWidth / (window.innerHeight - 128);
      camera.left   = (frustumSize * aspect) / -2;
      camera.right  = (frustumSize * aspect) /  2;
      camera.top    = frustumSize / 2;
      camera.bottom = frustumSize / -2;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight - 128);
      axisRenderer.setSize(160, 160);
    });
  </script>
</body>
</html>
