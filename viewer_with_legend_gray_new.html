<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>桥梁地形云图在线查看器</title>
  <style>
    :root{
      --bg:#ececec; --panel:#ffffffee; --text:#222; --muted:#667085;
      --primary:#315cf0; --primary-weak:#e7ecff; --border:#d9d9d9; --shadow:0 6px 20px rgba(0,0,0,.08);
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Microsoft YaHei",sans-serif;color:var(--text);}
    header#topbar{position:sticky;top:0;z-index:20;display:flex;gap:10px;align-items:center;padding:10px 12px;background:var(--panel);backdrop-filter:saturate(180%) blur(6px);border-bottom:1px solid var(--border)}
    #logo{width:32px;height:32px;object-fit:contain;border-radius:50%}
    #title{font-size:16px;font-weight:700;letter-spacing:.5px}
    #brand{margin-left:auto;display:flex;align-items:center;gap:8px}
    #brand img{width:36px;height:36px;border-radius:50%}
    #brand .name{font-weight:700;color:#22314a;font-size:14px}
    /* 工具区（两行自适应） */
    #toolbar{position:sticky;top:54px;z-index:19;display:grid;grid-template-columns:repeat(12,1fr);gap:8px;padding:10px 12px;background:var(--panel);border-bottom:1px solid var(--border)}
    .row{display:contents}
    .group{display:flex;gap:8px;align-items:center;background:#fff;border:1px solid var(--border);border-radius:10px;padding:8px 10px;box-shadow:var(--shadow)}
    .group label{font-size:13px;color:var(--muted)}
    select,button,input[type=range]{font-size:14px;border:1px solid var(--border);border-radius:8px;background:#fff;color:var(--text);padding:6px 10px}
    select{min-width:140px}
    button.primary{background:var(--primary);border-color:var(--primary);color:#fff}
    .toggle{padding:6px 10px;border-radius:20px;background:var(--primary-weak);border-color:#cbd5ff;color:#2946b8}
    .toggle[aria-pressed="true"]{background:var(--primary);color:#fff;border-color:var(--primary)}
    .muted{color:var(--muted)}
    #g1{grid-column:span 12} #g2{grid-column:span 12}
    @media (min-width:860px){ #g1{grid-column:span 7} #g2{grid-column:span 5} }
    /* 画布区 */
    #container{position:fixed;inset:0;top:128px}
    /* 底部HUD：不会被遮挡 */
    #hud{position:fixed;left:16px;bottom:16px;background:rgba(0,0,0,.65);color:#fff;padding:8px 10px;border-radius:8px;font-size:13px;white-space:pre;z-index:15}
    /* 右侧图例（可配置） */
    #legendBox{position:fixed;right:16px;top:148px;width:54px;z-index:16;text-align:center;font-size:12px;color:#333}
    #legend{width:20px;height:200px;margin:0 auto;border:1px solid #888;display:block}
    #legendMin,#legendMax{margin:4px 0 0 0}
    #legendUnit{color:#666;margin-top:2px}
    /* 小坐标系（正交，无外圈） */
    #axisWrap{position:fixed;right:16px;bottom:16px;width:180px;height:180px;pointer-events:none}
    #axisCanvas{position:absolute;inset:0;width:180px;height:180px;background:transparent;pointer-events:auto}
    /* 左下角水印校徽（可留可删） */
    #wm{position:fixed;left:10px;bottom:10px;opacity:.10;z-index:5;pointer-events:none}
    #wm img{width:110px;height:110px;object-fit:contain}
  </style>
  <script type="importmap">{"imports":{"three":"./three.module.js"}}</script>
</head>
<body>
  <!-- 顶栏 -->
  <header id="topbar">
    <img id="logo" src="./logo.png" alt="logo" />
    <div id="title">桥梁地形云图在线查看器</div>
    <div id="brand"><img src="./logo.png" alt="长安大学"/><span class="name">长安大学</span></div>
  </header>

  <!-- 工具区（两行响应式） -->
  <section id="toolbar">
    <div id="g1" class="row">
      <div class="group" style="grid-column:span 12;">
        <label>桥梁</label>
        <select id="bridgeSel"></select>
        <label>时间</label>
        <select id="dateSel"></select>
        <button id="loadBtn" class="primary">加载</button>
        <span id="status" class="muted" style="margin-left:auto">就绪</span>
      </div>
    </div>
    <div id="g2" class="row">
      <div class="group" style="grid-column:span 12;flex-wrap:wrap">
        <button id="modeBtn" class="toggle" aria-pressed="false" title="切换点云/网格">网格</button>
        <label>点大小</label>
        <input type="range" id="pointSize" min="0.5" max="5" step="0.1" value="1.5" style="width:160px">
        <button id="pickBtn" class="toggle" aria-pressed="false" title="单击拾取点">拾取</button>
        <button id="measureBtn" class="toggle" aria-pressed="false" title="两点测距">测距</button>
        <button id="clearBtn" class="toggle" aria-pressed="false">清除</button>
      </div>
    </div>
  </section>

  <!-- 画布 / 图例 / HUD / 小坐标系 / 水印 -->
  <div id="container"></div>
  <div id="legendBox">
    <canvas id="legend" width="20" height="200"></canvas>
    <div id="legendMin">min</div>
    <div id="legendMax">max</div>
    <div id="legendUnit">单位</div>
  </div>
  <div id="hud">提示：启用“拾取”或“测距”后，在模型上点击。</div>
  <div id="axisWrap"><canvas id="axisCanvas" width="180" height="180"></canvas></div>
  <div id="wm"><img src="./logo.png" alt="长安大学水印"/></div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from './OrbitControls.js';
    import { PLYLoader } from './PLYLoader.js';

    // ===== 场景基础 =====
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xcccccc);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/(window.innerHeight-128), 0.1, 100000);
    camera.position.set(100,100,100);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight-128);
    document.getElementById('container').appendChild(renderer.domElement);
    renderer.domElement.tabIndex = 0;

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(120, 220, 120);
    scene.add(dir);

    const root = new THREE.Group(); scene.add(root);

    // ===== 小坐标系（正交，无外圈） =====
    const axisScene = new THREE.Scene();
    const AXIS_CANVAS_SIZE = 180, AXIS_UNITS = 2.2;
    const axisCamera = new THREE.OrthographicCamera(-AXIS_UNITS, AXIS_UNITS, AXIS_UNITS, -AXIS_UNITS, -10, 10);
    axisCamera.position.set(0,0,2); axisCamera.up.set(0,1,0); axisCamera.lookAt(0,0,0);
    const axisRenderer = new THREE.WebGLRenderer({ canvas: document.getElementById('axisCanvas'), alpha:true, antialias:true });
    axisRenderer.setSize(AXIS_CANVAS_SIZE, AXIS_CANVAS_SIZE);
    const mini = new THREE.Group(); axisScene.add(mini); mini.scale.set(0.95,0.95,0.95);

    function makeLabelSprite(text, color){ const cvs=document.createElement('canvas'); const s=128; cvs.width=cvs.height=s;
      const ctx=cvs.getContext('2d'); ctx.clearRect(0,0,s,s); ctx.fillStyle=color; ctx.font='bold 72px Arial';
      ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(text,s/2,s/2);
      const tex=new THREE.CanvasTexture(cvs); const mat=new THREE.SpriteMaterial({map:tex,transparent:true});
      const sp=new THREE.Sprite(mat); sp.scale.set(0.9,0.9,0.9); return sp; }
    function addAxis(dir,color,name){
      const len=1.35, headLen=0.33, headWid=0.21;
      const ah=new THREE.ArrowHelper(dir,new THREE.Vector3(0,0,0),len,color,headLen,headWid);
      ah.userData.axis=name; mini.add(ah);
      const sp=makeLabelSprite(name,'#000'); sp.position.copy(dir.clone().multiplyScalar(1.5));
      sp.userData.axis=name; mini.add(sp);
    }
    addAxis(new THREE.Vector3(1,0,0),0xff4444,'X');
    addAxis(new THREE.Vector3(0,1,0),0x44ff44,'Y');
    addAxis(new THREE.Vector3(0,0,1),0x4488ff,'Z');

    const axisCanvas=document.getElementById('axisCanvas');
    const axisRay=new THREE.Raycaster(), axisMouse=new THREE.Vector2();
    axisCanvas.addEventListener('pointerdown',(e)=>{
      const rect=axisCanvas.getBoundingClientRect();
      axisMouse.x=((e.clientX-rect.left)/rect.width)*2-1; axisMouse.y=-((e.clientY-rect.top)/rect.height)*2+1;
      axisRay.setFromCamera(axisMouse,axisCamera);
      const hits=axisRay.intersectObjects(mini.children,true);
      if(!hits.length) return;
      const hit=hits.find(h=>h.object.userData.axis); const axis=hit?hit.object.userData.axis:(hits[0].object.userData.axis); if(!axis) return;
      snapToAxis(axis); try{axisCanvas.releasePointerCapture(e.pointerId);}catch(_){}
      renderer.domElement.focus(); e.preventDefault(); e.stopPropagation();
    });

    // ===== UI元素 =====
    const status=document.getElementById('status');
    const hud=document.getElementById('hud');
    const pointSize=document.getElementById('pointSize');
    const modeBtn=document.getElementById('modeBtn'); // "网格/点云"
    const pickBtn=document.getElementById('pickBtn');
    const measureBtn=document.getElementById('measureBtn');
    const clearBtn=document.getElementById('clearBtn');

    // ===== 变量 =====
    const loader=new PLYLoader();
    let currentObj=null, asPoints=false; // 默认网格
    let measureA=null, measureB=null, measureLine=null, measureAMarker=null, measureBMarker=null;
    let pickMarker=null;
    const raycaster=new THREE.Raycaster(), mouse=new THREE.Vector2();

    // ===== 图例（可配置：*.legend.json） =====
    const legendCanvas = document.getElementById('legend');
    const legendCtx = legendCanvas.getContext('2d');
    const legendMinEl = document.getElementById('legendMin');
    const legendMaxEl = document.getElementById('legendMax');
    const legendUnitEl= document.getElementById('legendUnit');

    // 默认彩虹
    let legendConfig = {
      min: 0, max: 1, unit: '',
      stops: [
        [0.00, '#0000ff'], [0.20, '#00ffff'], [0.40, '#00ff00'],
        [0.60, '#ffff00'], [0.80, '#ff7f00'], [1.00, '#ff0000']
      ]
    };
    function drawLegend(){
      const g = legendCtx.createLinearGradient(0, legendCanvas.height, 0, 0);
      for(const [t, color] of legendConfig.stops){ g.addColorStop(t, color); }
      legendCtx.fillStyle = g; legendCtx.fillRect(0,0,legendCanvas.width,legendCanvas.height);
      legendMinEl.textContent = legendConfig.min;
      legendMaxEl.textContent = legendConfig.max;
      legendUnitEl.textContent = legendConfig.unit || '';
    }
    drawLegend();

    // 侧车文件：与 PLY 同名的 *.legend.json
    async function loadLegendFor(plyUrl){
      try{
        const url = new URL(plyUrl, location.href);
        const fname = url.pathname.split('/').pop();
        const base = fname.replace(/\.ply$/i,'');
        url.pathname = url.pathname.replace(fname, base + '.legend.json');
        const res = await fetch(url.href + '?_=' + Date.now());
        if(!res.ok) return; // 没有就忽略
        const cfg = await res.json();
        // 允许三种写法：{legend:{...}} 或 直接 {...} 或带 stops/min/max/unit
        const lg = cfg.legend || cfg;
        if(lg && Array.isArray(lg.stops)) { legendConfig = { min: lg.min ?? 0, max: lg.max ?? 1, unit: lg.unit ?? '', stops: lg.stops }; drawLegend(); }
      }catch(e){ /* 忽略 */ }
    }
    /* 例：cloud.legend.json
      {
        "min": -5.0,
        "max":  5.0,
        "unit": "m",
        "stops": [
          [0.00,"#0000ff"], [0.25,"#00ffff"], [0.50,"#00ff00"], [0.75,"#ffff00"], [1.00,"#ff0000"]
        ]
      }
    */

    // ===== 工具函数 =====
    function sceneScale(){
      const box = new THREE.Box3().setFromObject(root);
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x,size.y,size.z);
      return (maxDim || 1);
    }
    function makeMarker(colorHex){
      const s = sceneScale() * 0.01; // 自动缩放：1%
      const geo = new THREE.SphereGeometry(s, 16, 16);
      const mat = new THREE.MeshBasicMaterial({ color: colorHex, depthTest:true });
      const mesh = new THREE.Mesh(geo, mat);
      // 白色外圈（描边）
      const edge = new THREE.Mesh(
        new THREE.SphereGeometry(s*1.3, 16, 16),
        new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.8, depthTest:true })
      );
      const g = new THREE.Group(); g.add(edge); g.add(mesh);
      return g;
    }
    function makeMeasureLine(a,b){
      const geo = new THREE.BufferGeometry().setFromPoints([a,b]);
      const mat = new THREE.LineBasicMaterial({ color: 0x00e0ff, linewidth: 2, transparent:true, opacity:0.95 });
      return new THREE.Line(geo, mat);
    }
    function updateMeasureLine(){
      if(measureLine && measureA && measureB){
        const pos = measureLine.geometry.attributes.position.array;
        pos[0]=measureA.x; pos[1]=measureA.y; pos[2]=measureA.z;
        pos[3]=measureB.x; pos[4]=measureB.y; pos[5]=measureB.z;
        measureLine.geometry.attributes.position.needsUpdate = true;
        measureLine.geometry.computeBoundingSphere?.();
      }
    }

    function fitObject(obj){
      const box=new THREE.Box3().setFromObject(obj);
      const size=box.getSize(new THREE.Vector3());
      const center=box.getCenter(new THREE.Vector3());
      const maxDim=Math.max(size.x,size.y,size.z)||1;
      const dist=maxDim/(2*Math.tan(Math.PI*camera.fov/360));
      camera.position.copy(center.clone().add(new THREE.Vector3(1,1,1).normalize().multiplyScalar(dist*2)));
      controls.target.copy(center); controls.update();
      camera.near=Math.max(0.01,dist/1000); camera.far=dist*10000; camera.updateProjectionMatrix();
    }
    function clearMeasure(){
      measureA=measureB=null;
      if (measureLine){ root.remove(measureLine); measureLine.geometry.dispose(); measureLine.material.dispose(); measureLine=null; }
      if (measureAMarker){ root.remove(measureAMarker); measureAMarker=null; }
      if (measureBMarker){ root.remove(measureBMarker); measureBMarker=null; }
    }
    function clearPick(){
      if(pickMarker){ root.remove(pickMarker); pickMarker=null; }
    }
    function clearScene(){
      if(currentObj){ root.remove(currentObj); currentObj.geometry?.dispose?.(); currentObj.material?.dispose?.(); currentObj=null; }
      clearMeasure(); clearPick();
      hud.textContent='提示：启用“拾取”或“测距”后，在模型上点击。';
    }

    // 彩色点/网格
    function makePoints(geometry){
      const hasColor=!!geometry.getAttribute('color');
      const mat=new THREE.PointsMaterial({ size:parseFloat(pointSize.value), vertexColors:hasColor });
      return new THREE.Points(geometry,mat);
    }
    function makeMesh(geometry){
      if(geometry.index) geometry=geometry.toNonIndexed();
      geometry.computeVertexNormals?.();
      const mat=new THREE.MeshLambertMaterial({ vertexColors:true, side:THREE.DoubleSide });
      return new THREE.Mesh(geometry,mat);
    }

    async function loadPLY(url){
      status.textContent='加载中...'; clearScene();
      // 先尝试加载图例配置
      loadLegendFor(url);
      loader.load(url,(geometry)=>{
        geometry.computeBoundingBox?.();
        currentObj = asPoints ? makePoints(geometry) : makeMesh(geometry);
        root.add(currentObj); fitObject(currentObj); status.textContent='加载完成';
      },(xhr)=>{ if(xhr.total) status.textContent='下载 '+(xhr.loaded/xhr.total*100).toFixed(1)+'%'; },
      (err)=>{ console.error(err); status.textContent='加载失败，请检查路径'; });
    }

    pointSize.addEventListener('input', ()=>{
      if(currentObj && currentObj.material && currentObj.material.size!==undefined){
        currentObj.material.size=parseFloat(pointSize.value);
      }
    });

    // 点/网格切换按钮
    function refreshModeLabel(){ modeBtn.textContent = asPoints ? '点云' : '网格'; modeBtn.setAttribute('aria-pressed', asPoints ? 'true':'false'); }
    refreshModeLabel();
    modeBtn.addEventListener('click', ()=>{
      asPoints=!asPoints; refreshModeLabel();
      if(currentObj && currentScene?.plyUrl) loadPLY(currentScene.plyUrl);
    });

    // 拾取/测距按钮
    function setToggle(btn,on){ btn.setAttribute('aria-pressed', on?'true':'false'); }
    function isOn(btn){ return btn.getAttribute('aria-pressed')==='true'; }
    pickBtn.addEventListener('click',()=>{ setToggle(pickBtn,!isOn(pickBtn)); if(isOn(pickBtn)) setToggle(measureBtn,false); });
    measureBtn.addEventListener('click',()=>{ setToggle(measureBtn,!isOn(measureBtn)); if(isOn(measureBtn)) setToggle(pickBtn,false); });
    clearBtn.addEventListener('click',()=>{ clearMeasure(); clearPick(); hud.textContent='已清除测距/拾取结果'; });

    // 主画布点击：拾取 / 测距
    renderer.domElement.addEventListener('pointerdown',(e)=>{
      if(!currentObj) return;
      if(!isOn(pickBtn) && !isOn(measureBtn)) return;
      const rect=renderer.domElement.getBoundingClientRect();
      mouse.x=((e.clientX-rect.left)/rect.width)*2-1;
      mouse.y=-((e.clientY-rect.top)/rect.height)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const hits=raycaster.intersectObject(currentObj,true);
      if(!hits.length) return;
      const p=hits[0].point.clone();

      if(isOn(pickBtn)){
        clearPick();
        pickMarker = makeMarker(0x9a4dff);
        pickMarker.position.copy(p); root.add(pickMarker);
        hud.textContent=`拾取\nX:${p.x.toFixed(3)}\nY:${p.y.toFixed(3)}\nZ:${p.z.toFixed(3)}`;
      }
      if(isOn(measureBtn)){
        if(!measureA){
          measureA=p.clone();
          if(measureAMarker){ root.remove(measureAMarker); }
          measureAMarker = makeMarker(0x00e0ff); measureAMarker.position.copy(measureA); root.add(measureAMarker);
          hud.textContent=`测距(A)\nX:${measureA.x.toFixed(3)} Y:${measureA.y.toFixed(3)} Z:${measureA.z.toFixed(3)}`;
        }else if(!measureB){
          measureB=p.clone();
          if(measureBMarker){ root.remove(measureBMarker); }
          measureBMarker = makeMarker(0xff6a00); measureBMarker.position.copy(measureB); root.add(measureBMarker);
          const dx=measureB.x-measureA.x, dy=measureB.y-measureA.y, dz=measureB.z-measureA.z;
          const d=Math.sqrt(dx*dx+dy*dy+dz*dz);
          if(!measureLine){ measureLine = makeMeasureLine(measureA, measureB); root.add(measureLine); } else { updateMeasureLine(); }
          hud.textContent=`ΔX:${dx.toFixed(3)}\nΔY:${dy.toFixed(3)}\nΔZ:${dz.toFixed(3)}\nD:${d.toFixed(3)}`;
        }else{
          clearMeasure();
          measureA=p.clone();
          measureAMarker = makeMarker(0x00e0ff); measureAMarker.position.copy(measureA); root.add(measureAMarker);
          hud.textContent=`测距(A)\nX:${measureA.x.toFixed(3)} Y:${measureA.y.toFixed(3)} Z:${measureA.z.toFixed(3)}`;
        }
      }
    });

    // index.json → 下拉
    let bridges=[], scenes=[], currentScene=null;
    async function loadIndex(){
      const res=await fetch('./index.json?_='+Date.now());
      const data=await res.json();
      bridges=data.bridges||[]; scenes=data.scenes||[];
      document.getElementById('bridgeSel').innerHTML=bridges.map(b=>`<option value="${b.id}">${b.name}</option>`).join('');
      fillDates();
      const id=document.getElementById('dateSel').value;
      currentScene=scenes.find(x=>x.id===id); if(currentScene) loadPLY(currentScene.plyUrl);
    }
    function fillDates(){
      const bid=document.getElementById('bridgeSel').value;
      const arr=scenes.filter(s=>s.bridgeId===bid);
      document.getElementById('dateSel').innerHTML=arr.map(s=>`<option value="${s.id}">${s.date}</option>`).join('');
    }
    document.getElementById('bridgeSel').addEventListener('change',()=>{
      fillDates();
      const id=document.getElementById('dateSel').value;
      currentScene=scenes.find(x=>x.id===id);
    });
    document.getElementById('dateSel').addEventListener('change',()=>{
      const id=document.getElementById('dateSel').value;
      currentScene=scenes.find(x=>x.id===id);
    });
    document.getElementById('loadBtn').addEventListener('click',()=>{
      const id=document.getElementById('dateSel').value;
      currentScene=scenes.find(x=>x.id===id);
      if(currentScene) loadPLY(currentScene.plyUrl);
    });

    // 视图对正
    function getSceneCenter(){
      if(root.children.length===0) return new THREE.Vector3();
      return new THREE.Box3().setFromObject(root).getCenter(new THREE.Vector3());
    }
    function currentDistanceTo(target){ return camera.position.clone().sub(target).length(); }
    function snapToAxis(axis){
      const center=getSceneCenter(); const dist=Math.max(1,currentDistanceTo(center));
      let pos=new THREE.Vector3(); let up=new THREE.Vector3(0,0,1);
      if(axis==='X'){ pos.set(dist,0,0); up.set(0,0,1); }
      if(axis==='Y'){ pos.set(0,dist,0); up.set(0,0,1); }
      if(axis==='Z'){ pos.set(0,0,dist); up.set(0,1,0); }
      camera.up.copy(up); camera.position.copy(center.clone().add(pos));
      controls.target.copy(center); controls.update();
    }

    // 自适应
    window.addEventListener('resize',()=>{
      camera.aspect=window.innerWidth/(window.innerHeight-128); camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight-128);
      axisRenderer.setSize(AXIS_CANVAS_SIZE,AXIS_CANVAS_SIZE);
      axisCamera.left=-AXIS_UNITS; axisCamera.right=AXIS_UNITS; axisCamera.top=AXIS_UNITS; axisCamera.bottom=-AXIS_UNITS; axisCamera.updateProjectionMatrix();
    });

    // 循环
    (function animate(){
      requestAnimationFrame(animate);
      controls.update(); renderer.render(scene,camera);
      mini.position.set(0,0,0); mini.quaternion.copy(camera.quaternion);
      axisCamera.lookAt(0,0,0); axisRenderer.render(axisScene,axisCamera);
    })();

    loadIndex();
  </script>
</body>
</html>
